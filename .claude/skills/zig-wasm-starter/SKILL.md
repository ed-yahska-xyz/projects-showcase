---
name: zig-wasm-starter
description: Scaffolds a starter web project that uses web assembly to do the heavy lifting and use web as just the front end.
---

# Zig + WASM Project Starter

This skill scaffolds a new project that uses Zig compiled to WebAssembly with HTML, CSS, and JavaScript as the front end.

## Instructions

When the user invokes this skill, follow these steps:

### Step 1: Gather Project Info

Ask the user for:
1. **Project name** (e.g., "particles", "game-of-life") - this will be used for the folder name and file names
2. **Brief description** of what the project will do

### Step 2: Create Project Structure

Create the following folder structure under the repository root:

```
[project-name]/
├── wasm/
│   ├── [project-name].zig    # Zig source code
│   └── build.zig             # Zig build configuration
├── index.html                # Web page
├── index.js                  # JavaScript to load WASM and handle UI
├── style.css                 # Styling
└── [project-name].wasm       # (Generated by build)
```

### Step 3: Create the Files

#### 3a. Create `wasm/build.zig`

```zig
const std = @import("std");

const wasm_initial_memory = 32 * std.wasm.page_size;
const wasm_max_memory = wasm_initial_memory;

pub fn build(b: *std.Build) !void {
    const target = b.resolveTargetQuery(.{
        .cpu_arch = .wasm32,
        .os_tag = .freestanding,
    });

    const exe = b.addExecutable(.{
        .name = "[PROJECT_NAME]",
        .root_source_file = b.path("[project-name].zig"),
        .target = target,
        .optimize = .ReleaseSmall,
    });

    exe.entry = .disabled;
    exe.rdynamic = true;
    exe.import_memory = true;
    exe.import_symbols = true;

    const exe_options = b.addOptions();
    exe_options.addOption(usize, "memory_size", wasm_max_memory);
    exe.root_module.addOptions("build_options", exe_options);
    b.installArtifact(exe);
}
```

Replace `[PROJECT_NAME]` with the capitalized project name and `[project-name]` with the lowercase project name.

#### 3b. Create `wasm/[project-name].zig`

Create a minimal Zig file with:
- Import for build_options
- External memory declaration
- An `alloc` export function for memory allocation
- A simple exported function relevant to the project purpose

```zig
const std = @import("std");
const build_options = @import("build_options");

var gpa = std.heap.GeneralPurposeAllocator(.{}){};
const allocator = gpa.allocator();

// Allocate memory that JavaScript can use
export fn alloc(len: usize) ?[*]f32 {
    const arr = allocator.alloc(f32, len) catch return null;
    @memset(arr, 0.0);
    return arr.ptr;
}

// Add project-specific exported functions here
export fn update() void {
    // Main update logic
}
```

#### 3c. Create `index.html`

```html
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="/[project-name]/style.css" />
    <title>[Project Title]</title>
  </head>
  <body>
    <div id="app">
      <canvas id="canvas"></canvas>
    </div>
    <script src="/[project-name]/index.js"></script>
  </body>
</html>
```

#### 3d. Create `index.js`

```javascript
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");

// Set canvas size
function resizeCanvas() {
  const container = document.querySelector('#app');
  canvas.width = container.clientWidth;
  canvas.height = container.clientHeight;
}
resizeCanvas();
window.addEventListener('resize', resizeCanvas);

// WASM memory shared with Zig
const memory = new WebAssembly.Memory({
  initial: 32,
  maximum: 100
});

const importObject = {
  env: {
    memoryBase: 0,
    tableBase: 0,
    memory: memory,
    table: new WebAssembly.Table({ initial: 32, element: 'anyfunc' }),
    abort: console.error,
  }
};

// Load and run WASM
WebAssembly.instantiateStreaming(fetch('/[project-name]/[project-name].wasm'), importObject)
  .then((result) => {
    const exports = result.instance.exports;

    // Start animation loop
    function update() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Call WASM functions here
      // exports.update();

      requestAnimationFrame(update);
    }

    requestAnimationFrame(update);
  });
```

#### 3e. Create `style.css`

```css
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

#app {
  position: absolute;
  left: 0;
  right: 0;
  top: 0;
  bottom: 0;
}

canvas {
  display: block;
}
```

### Step 4: Build Instructions

After creating the files, tell the user how to build:

```bash
cd [project-name]/wasm
zig build
cp zig-out/bin/[PROJECT_NAME].wasm ../[project-name].wasm
```

Or they can serve the project and build will happen as part of their workflow.

## Notes

- The WASM is loaded via `fetch()` so the project needs to be served (not opened as a file)
- Memory is shared between JavaScript and Zig via WebAssembly.Memory
- Exported Zig functions are available on `result.instance.exports`
- Use `f32` arrays for data that needs to be shared between JS and Zig